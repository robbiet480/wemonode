var eventEmitter = require('events').EventEmitter;
var util = require('util');
var dgram = require('dgram');
var http = require('http');
var fs = require('fs');


var _instance;

function WemoNode() {

    if (typeof _instance !== 'undefined') {
        return _instance;
    }

    if (!(this instanceof WemoNode)) return new arguments.callee();
    _instance = this;

    arguments.callee.super_.apply(this, arguments);

    // Constants
    var SSDP_IP = '239.255.255.250',
        SSDP_PORT = 1900,
        SSDP_IPPORT = SSDP_IP + ':' + SSDP_PORT;


    this.wemoObjects = [];


    // Creating socket
    var udpsocket = dgram.createSocket('udp4');

    // UDP Socket functions
    this._socket_errorHandler = function(err) {
        console.error("UDP Socket error: " + err);
    }.bind(this);

    this._socket_listeningHandler = function() {
        var addr = udpsocket.address();
        //console.log('Listening on ' + addr.address + ':' + addr.port);
        udpsocket.addMembership(SSDP_IP);
        udpsocket.setMulticastTTL(2);
        this._updateBinaryStates();
    }.bind(this);

    this._socket_messageHandler = function(msg, rinfo) {
        var objectLocation, objectUSN;
        var found = false;

        var tokens = msg.toString().split('\r\n');

        for (var i = 0; i < tokens.length; i++) {
            var tmp = tokens[i];
            if (tmp.indexOf("LOCATION:") >= 0) {
                objectLocation = tmp.substr(9).trim();
            }
            else if (tmp.indexOf("USN:") >= 0) {
                objectUSN = tmp.substr(4).trim();
            }

            if (objectLocation && objectUSN) {
                break;
            }
        }
        /* Continue only if both objectLocation and objectUSN are found */
        if (objectLocation == 'undefined' || objectUSN == 'undefined') return;

        /* Continue only if found device is a Belkin WeMo device */
        if (objectUSN.indexOf("Belkin:service:basicevent:1") < 0) return;


        /* Search if wemoObjects Array already contains found object */
        for (var i = 0, k = this.wemoObjects.length; i < k; i++) {
            if (this.wemoObjects[i].USN == objectUSN) {
                this.wemoObjects[i].lastSeen = +new Date;
                found = true;
                break;
            }
        }

        /* If not found, this means that item is not in array, so is new */
        if (!found) {
            var deviceType, id, lastSeen;
            var location = objectLocation;
            var ipaddress = location.substr(7);
            var port = ipaddress.substr(ipaddress.indexOf(":") + 1);
            port = port.substr(0, port.indexOf("/"));
            ipaddress = ipaddress.substring(0, ipaddress.indexOf(":"));
            //obj.USN = objectUSN;

            if (objectUSN.indexOf("uuid:Socket") >= 0)
                deviceType = "socket";
            else {
                deviceType = "sensor";
            }

            id = objectUSN.substr(16);
            id = id.substr(0, id.indexOf(":"));

            lastSeen = +new Date;

            var obj = {
                deviceType: deviceType,
                id: id,
                lastSeen: lastSeen,
                location: location,
                ipaddress: ipaddress,
                port: port,
                USN: objectUSN
            };

            this.wemoObjects.push(obj);
            this.emit("device_found", obj);

            obj = null;
        }

        /* Check expired devices */
        var expired = this.wemoObjects.filter(function (item) {
            return (+new Date - item.lastSeen) > 30000;
        });

        expired.forEach(function (item) {
            _self.emit("device_lost", item);
            this.wemoObjects.splice(this.wemoObjects.indexOf(item), 1);
        }, this);
    }.bind(this);


    // Adding socket listeners
    udpsocket.on('error', this._socket_errorHandler);
    udpsocket.on('listening',this._socket_listeningHandler);
    udpsocket.on('message', this._socket_messageHandler);



    // Creates SSDP header from variables
    this.getSSDPHeader = function (head, vars, res) {
        var ret;
        res = res || false;
        ret = res ? "HTTP/1.1 " + head + "\r\n" : head + " HTTP/1.1\r\n";
        for (var n in vars) {
            ret += n + ": " + vars[n] + "\r\n";
        }
        return ret + "\r\n";
    }

    this._readConfigFileHandler = function(err,data) {
        if (err)
            console.error("Error reading wemonode_config.json: " + err.toString());
        dataObj = JSON.parse(data.toString());
        this.socketClosed = false;
        udpsocket.bind(0, dataObj.upnpBindAddress);
        this._startDiscoveryMessageSending();
    }.bind(this);


    // Methods
    this.startDiscovery = function () {
        //var _self = this;
        fs.readFile('wemonode_config.json',this._readConfigFileHandler);
    }.bind(this);




    this.stopDiscovery = function () {
        try {
            this.socketClosed = true;
            this._timeout && clearTimeout(this._timeout);
            this._binaryStateTimeout && clearTimeout(this._binaryStateTimeout);

            udpsocket.close();

        }
        catch (err) {
            console.error(err);
        }

    }.bind(this);


    this.sendCommand = function (command, device, parameters, callback) {
        fs.exists('node_modules/wemonode/commands/' + command + '.json', function (exists) {
            if (!exists) {
                if (callback) {
                    callback('EINVALIDCOMMAND', null);
                    callback = null;
                }

            }
            else {
                fs.readFile('node_modules/wemonode/commands/' + command + '.json', function (err, data) {
                    var commandObj = JSON.parse(data.toString());

                    if (commandObj.appliesTo.indexOf(device.deviceType) < 0) {
                        if (callback) {
                            callback('ENOTAPPLICABLE', null);
                            callback = null;
                        }


                    }
                    else {
                        var options = {
                            hostname: device.ipaddress,
                            port: device.port,
                            path: commandObj.path,
                            method: 'POST',
                            headers: {
                                'SOAPACTION': commandObj.soapAction,
                                'content-type': 'text/xml',
                                'charset': 'utf-8'
                            }
                        }

                        var req = http.request(options, function (res) {
                            res.setEncoding('utf8');
                            res.on('data', function (chunk) {
                                if (callback) {
                                    callback(null, chunk);
                                    callback = null;
                                }

                            });
                        }.bind(this));
                        req.setTimeout(2000);
                        req.on("error", function (err) {
                        });


                        var envelope = commandObj.envelope;

                        if (parameters) {
                            for (var key in parameters) {
                                envelope = envelope.replace('$$' + key.toUpperCase() + '$$', parameters[key]);
                            }
                        }
                        req.write(envelope);
                        req.end();


                    }
                    parameters = null;
                    device = null;
                }.bind(this));
            }


        }.bind(this));

    }

    // Funzioni interne

    this._startDiscoveryMessageSending = function () {
        var pkt = this.getSSDPHeader('M-SEARCH *', {
            HOST: SSDP_IPPORT,
            ST: 'urn:Belkin:service:basicevent:1',
            MAN: '"ssdp:discover"',
            MX: 3
        });

        pkt = new Buffer(pkt);

        this._sendViaSocket(pkt);

        this._timeout = setTimeout(this._startDiscoveryMessageSending.bind(this), 5000);


    }.bind(this);

    this._sendViaSocket = function (pkt) {
        try {
            udpsocket.send(pkt, 0, pkt.length, SSDP_PORT, SSDP_IP);
        }
        catch (err) {
            console.error("Error sending UDP message: " + err.toString());
        }
    }


    this._updateBinaryStates = function () {

        this.wemoObjects.forEach(function (singleObject) {

            this.sendCommand("both_getbinarystate", singleObject, null, function (err, response) {
                err = err || false;
                if (err) {
                    return;
                }
                var currentState = response.substr(response.indexOf('<BinaryState>'));
                currentState = currentState.substr(13, 1);

                if (singleObject.binarystate != currentState) {
                    singleObject.binarystate = +currentState;
                    this.emit("state_changed", singleObject);
                }
            }.bind(this));
        }.bind(this));


        if (!this.socketClosed)
            this._binaryStateTimeout = setTimeout(this._updateBinaryStates.bind(this), 1000);
    }.bind(this);
}

util.inherits(WemoNode, eventEmitter);


exports.WemoNode = WemoNode;
